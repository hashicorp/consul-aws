SHELL := /usr/bin/env bash -euo pipefail -c

PRODUCT_NAME ?= consul-aws
BIN_NAME     ?= $(PRODUCT_NAME)
GOPATH       ?= $(shell go env GOPATH)
GOBIN        ?= $(GOPATH)/bin

VERSION = $(shell head -n 1 version/VERSION)
GOLANG_VERSION ?= $(shell head -n 1 .go-version)

DEV_IMAGE?=consul-aws-dev
GO_BUILD_TAG?=consul-aws-build-go
GIT_COMMIT?=$(shell git rev-parse --short HEAD)
GIT_DIRTY?=$(shell test -n "`git status --porcelain`" && echo "+CHANGES" || true)
GIT_DESCRIBE?=$(shell git describe --tags --always)
GIT_IMPORT=github.com/hashicorp/consul-aws/version
GOLDFLAGS=-X $(GIT_IMPORT).GitCommit=$(GIT_COMMIT)$(GIT_DIRTY)

# Get local ARCH; on Intel Mac, 'uname -m' returns x86_64 which we turn into amd64.
# Not using 'go env GOOS/GOARCH' here so 'make docker' will work without local Go install.
ARCH     ?= $(shell A=$$(uname -m); [ $$A = x86_64 ] && A=amd64; echo $$A)
OS       ?= $(shell go env GOOS)
PLATFORM = $(OS)/$(ARCH)
DIST     = dist/$(PLATFORM)
BIN      = $(DIST)/$(BIN_NAME)

# Docker Stuff.
export DOCKER_BUILDKIT=1
BUILD_ARGS = BIN_NAME=$(BIN_NAME) PRODUCT_VERSION=$(VERSION) PRODUCT_REVISION=$(REVISION)
TAG        = $(PRODUCT_NAME):$(VERSION)
BA_FLAGS   = $(addprefix --build-arg=,$(BUILD_ARGS))
FLAGS      = --target $(TARGET) --platform linux/$(ARCH) --tag $(TAG) $(BA_FLAGS)

HTTP_FLAGS_PACKAGE_DIR=internal/flags

dist: ## make dist directory and ignore everything
	mkdir -p $(DIST)
	echo '*' > dist/.gitignore

.PHONY: bin
bin: dist ## Build the binary
	GOARCH=$(ARCH) GOOS=$(OS) CGO_ENABLED=0 go build -trimpath -buildvcs=false -ldflags="$(GOLDFLAGS)" -o $(BIN) .

linux:  ## Linux builds a linux binary compatible with the source platform
	@mkdir -p ./dist/linux/$(ARCH)/$(BIN_NAME)
	CGO_ENABLED=0 GOOS=linux GOARCH=$(ARCH) go build -o ./dist/linux/$(ARCH)/$(BIN_NAME) -ldflags "$(GOLDFLAGS)" -tags "$(GOTAGS)"

.PHONY: dev
dev: bin ## Build binary and copy to the destination
	cp $(BIN) $(GOBIN)/$(BIN_NAME)

# build is used for the CRT build.yml workflow.
# Environment variables are populated by hashicorp/actions-go-build, not the makefile.
# https://github.com/hashicorp/actions-go-build
.PHONY: build
build:
	CGO_ENABLED=0 go build \
		-a \
		-o="${BIN_PATH}" \
		-ldflags " \
			-X 'github.com/hashicorp/http-echo/version.GitCommit=${PRODUCT_REVISION}' \
		" \
		-tags "${GOTAGS}" \
		-trimpath \
		-buildvcs=false

.PHONY: docker
docker: linux ## build the release-target docker image
	$(eval TARGET := release-default) # there are many targets in the Dockerfile, add more build if you need to customize the target
	docker build $(FLAGS) .
	@echo 'Image built; run "docker run --rm $(TAG)" to try it out.'

docker-run: docker ## run the image of $(TAG)
	docker run --rm $(TAG)

.PHONY: dev-docker
dev-docker: docker ## build docker image and tag the image to local
	docker tag '$(PRODUCT_NAME):$(VERSION)'  '$(PRODUCT_NAME):local'

test:
	go test ./...

tools:
	go get -u -v $(GOTOOLS)

clean:
	@rm -rf \
		$(CURDIR)/bin \
		$(CURDIR)/pkg

# We support all the same CLI flags for connecting to Consul as the main CLI.
# Rather than import the root Consul module, which is not supported, we copy the
# relevant module. This is similar to what we do in consul-dataplane.
# We don't include config_test.go because it pulls in a directory with test data.
.PHONY: copy-http-flags
copy-http-flags: ## copy http flags modules from consul
	for file in config.go http.go http_test.go merge.go usage.go; do \
		curl --fail https://raw.githubusercontent.com/hashicorp/consul/main/command/flags/$$file | \
		sed 's/BUSL-1.1/MPL-2.0/' | \
		sed '1s:^:// Code generated by make copy-http-flags. DO NOT EDIT.\n:' | \
		gofmt \
		> $(HTTP_FLAGS_PACKAGE_DIR)/$$file; \
	done

.PHONY: all bin clean dev dist docker-images go-build-image test tools docker-publish
